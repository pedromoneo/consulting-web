rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is admin
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }

    // Helper function to check if user is owner
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }

    // User Collection Rules
    match /users/{userId} {
      // Allow user to read/write their own profile, or admin
      allow read, write: if request.auth != null && (isOwner(userId) || isAdmin());

      // Chat History Subcollection Rules
      match /chatHistory/{chatId} {
        allow read, write: if request.auth != null && (isOwner(userId) || isAdmin());
      }
    }
    
    // Allow read access to public content
    // Adjust based on other collections (e.g. 'cases', 'ideas', 'tools') if needed.
    // Assuming for now we only strictly control users. 
    // If other collections exist, user needs to add them.
    // I'll add permissive read for development if user wants, but robust rules are better.
    
    // Cases, experts, tools, etc. (assuming they are public read)
    match /cases/{caseId} { allow read: if true; allow write: if request.auth != null && isAdmin(); }
    match /experts/{expertId} { allow read: if true; allow write: if request.auth != null && isAdmin(); }
    match /tools/{toolId} { allow read: if true; allow write: if request.auth != null && isAdmin(); }
    match /ideas/{ideaId} { allow read: if true; allow write: if request.auth != null && isAdmin(); }
    match /content/{docId} { allow read: if true; allow write: if request.auth != null && isAdmin(); }

  }
}
